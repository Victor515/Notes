# Overview

Protocol Buffers are a language-neutral, platform-neutral extensible mechanism for **serializing structured** data

It’s like JSON, except it’s **smaller and faster**, and it **generates native language bindings**

The format is suitable for both ephemeral network traffic and long-term data storage.



How Protobuf works:

![img](https://protobuf.dev/images/protocol-buffers-concepts.png)

Required is Forever: Protobuf forbids the use of required field starting proto 3. **Semantics for required fields should be implemented at the application layer instead**.

After setting optionality and field type, you assign a field number. **Field numbers cannot be repurposed or reused**. If you delete a field, you should reserve its field number to prevent someone from accidentally reusing the number



# Java Tutorial

## Writing .Proto Files

example:

```java
syntax = "proto2";

package tutorial;

option java_multiple_files = true;
option java_package = "com.example.tutorial.protos";
option java_outer_classname = "AddressBookProtos";

message Person {
  optional string name = 1;
  optional int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    optional string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phones = 4;
}

message AddressBook {
  repeated Person people = 1;
}
```



### Field Modifiers

`optional`: For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of an optional (or required) field which has not been explicitly set always returns that field’s default value.

`repeated`: the field may be repeated any number of times (including zero). Think of repeated fields as **dynamically sized arrays**.

### No class inheritance

Don’t go looking for facilities similar to class inheritance, though – **protocol buffers don’t do that.**

### Importing Definitions

You can use definitions from other `.proto` files by *importing* them. To import another `.proto`’s definitions, you add an import statement to the top of your file:

```proto
import "myproject/other_protos.proto";
```

### Enum behaviors

1. Enums have two distinct flavors (*open* and *closed*). 

```java
enum Enum {
  A = 0;
  B = 1;
}

message Msg {
  optional Enum enum = 1;
}
```

The distinction between *open* and *closed* can be encapsulated in a single question:

> What happens when a program parses binary data that contains field 1 with the value `2`?

- **Open** enums will parse the value `2` and store it directly in the field. Accessor will report the field as being *set* and will return something that represents `2`.
- **Closed** enums will parse the value `2` and store it in the message’s unknown field set. Accessors will report the field as being *unset* and will return the enum’s default value.



2. Prior to the introduction of `syntax = "proto3"` all enums were *closed*. Proto3 introduced *open* enums specifically because of the unexpected behavior that *closed* enums cause.



## Compiling Your Protocol Buffers

To do this, you need to run the protocol buffer compiler `protoc` on your `.proto`

```
protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/addressbook.proto
```



## The Protocol Buffer API

1. Notice how these accessor methods use camel-case naming, even though the `.proto` file uses lowercase-with-underscores. This transformation is done automatically by the protocol buffer compiler so that the generated classes match standard Java style conventions.

2. Builders vs. Messages
   * The message classes generated by the protocol buffer compiler are all *immutable*.
   * To construct a message, you must first construct a builder, set any fields you want to set to your chosen values, then call the builder’s `build()` method.

3. standard message methods:
   * `isInitialized()`: checks if all the required fields have been set.
   * `toString()`: returns a human-readable representation of the message, particularly useful for debugging.
   * `mergeFrom(Message other)`: (builder only) merges the contents of `other` into this message, overwriting singular scalar fields, merging composite fields, and concatenating repeated fields.
   * `clear()`: (builder only) clears all the fields back to the empty state.
4. For parsing and serialization:
   * `byte[] toByteArray();`: serializes the message and returns a byte array containing its raw bytes.
   * `static Person parseFrom(byte[] data);`: parses a message from the given byte array.
   * `void writeTo(OutputStream output);`: serializes the message and writes it to an `OutputStream`.
   * `static Person parseFrom(InputStream input);`: reads and parses a message from an `InputStream`.

5. check the note on "Protocol Buffers and Object Oriented Design", my takeaway: **You should never add behavior to the generated classes by inheriting from them**. Instead, use wrapper classes over generated classes



## Extending a Protocol Buffer

If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible, in the new version of the protocol buffer:

- you *must not* change the tag numbers of any existing fields.
- you *must not* add or delete any required fields.
- you *may* delete optional or repeated fields.
- you *may* add new optional or repeated fields but you must use fresh tag numbers (that is, tag numbers that were never used in this protocol buffer, not even by deleted fields).

Forward compatibility: old code will happily read new messages and simply ignore any new fields. To the old code, optional fields that were deleted will simply have their default value, and deleted repeated fields will be empty.

Backward compatibility: New code will also transparently read old messages. However:

* keep in mind that new optional fields will not be present in old messages, so you will need to either **check explicitly** whether they’re set with `has_`, or **provide a reasonable default value** in your `.proto` file with `[default = value]` after the tag number.

